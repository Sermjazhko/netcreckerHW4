# Task 1
![image](https://user-images.githubusercontent.com/43463670/167627536-62663192-3c29-4acb-8042-d794e468a57a.png)
![image](https://user-images.githubusercontent.com/43463670/167627573-d9af4803-792e-4f4c-91ed-76475f351e8e.png)
В целом реализованный список показал схожие по быстроте результаты при удалении и поиске объектов. При увеличении размера списка добавление эементов в конец несколько хуже по времени, чем у java-реализации.

# Task 2
1. ArrayList и LinkedList

|                             |  ArrayList  |  LinkedList |
| --------------------------- | ---------- | ----------- |
| add (в начало)              |     O(n)    |   O(1)
| add (в середину)            |     O(n)    |   O(n)
| add (в конец списка)        |     O(n)    |   O(1)   
| get (первый элемент)        |     O(1)    |   O(1)
| get (из середины)           |     O(1)    |   O(n)
| get (последний элемент)     |     O(1)    |   O(1)
| remove (первый элемент)     |     O(1)    |   O(1)
| remove (из середины)        |     O(n)    |   O(n)
| remove (последний элемент)  |     O(n)    |   O(1)

При большом количестве добавляемых элементов лучше использовать ArrayList, а также для вставки элементов в середину списка. Если говорить о вставке одного элемента, то LinkedList лучше, т.к. сложность такого алгоритма О(1) против O(n) у ArrayList. 
Поиск элементов практически одинаков по времени. 
Для удаления элементов: удаление из начала быстрее у LinkedList, из конца - у ArrayList. 

2. HashSet, LinkedHashSet и TreeSet

|                             |  HashSet    | LinkedHashSet | TreeSet |
| --------------------------- | ----------- | ------------- |-------- |
| add                         |     O(1)    |   O(1)        | O(log n) 
| contains                    |     O(1)    |   O(1)        | O(log n)
| remove                      |     O(1)    |   O(1)        | O(log n)

HashSet реализован на основе хеш-таблицы, TreeSet – на основе бинарного дерева, в LinkedHashSet сохраняется порядок вставки элементов. HashSet гораздо быстрее чем TreeSet (константное время против логарифмического для add, remove, contains), но TreeSet гарантирует упорядоченность объектов. Экспериментально было получено, что добавление эффективнее у HashSet. Удаление лучше у LinkedHashSet. Поиск элементов примерно одинаков у HashSet и LinkedHashSet. TreeSet хуже по производительности.

2.3 HashMap, LinkedHashMap, TreeMap

|                             |  HashMap    | LinkedHashMap | TreeMap |
| --------------------------- | ----------- | ------------- |-------- |
| add                         |     O(1)    |   O(1)        | O(log n) 
| contains                    |     O(1)    |   O(1)        | O(log n)
| remove                      |     O(1)    |   O(1)        | O(log n)

HashMap не дает никаких гарантий относительно порядка элементов, он изменяется при добавлении новых элементов. LinkedHashMap сохраняет элементы в порядке добавления в Map. У TreeMap в соответствии с порядком возрастания ключа при обходе. По производительности аналогично предыдущему пункту. Добавление быстрее у HashMap. Поиск и удаление - LinkedHashMap иHashMap. Дольше всего справляется TreeMap.
